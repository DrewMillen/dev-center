---
title: Activity Input Validation
description: Geocortex Workflow - Validate activity input in .NET custom activities
---

## Scope

This article applies to building workflow activities that will be run in [.NET workflow hosts](concepts-key-concepts.mdx#geocortex-workflow-hosts).

## Activity Input Validation Helpers

When you build a custom activity with inputs, you need to validate those inputs to ensure the user provided them and that they are of the same type. The .NET workflow runtime provides a number of helper functions to make this easier.

1. Add the line `using Geocortex.Workflow.Runtime.Utils;` to the top of your activity file.
1. Use intellisense to examine the new methods available on the `inputs` dictionary passed into the activity, such as `EnsureBool`, or `EnsureDoubleStrict`.

:::note
The difference between strict and non-strict validators is that strict validators will throw if the value is not present or if it is the wrong type, while non-strict validators will just soft fail.
:::

Use these `Ensure*` methods to validate your activity inputs and provide useful error messages.

## Example: Logarithm Activity

Here's an example of the [logarithm activity](implement-custom-activity-mobile.mdx#example-logarithm-of-a-number) that has been refactored to use the `Ensure*` methods.

```csharp
using Geocortex.Workflow.Runtime;
using Geocortex.Workflow.Runtime.Utils;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace App1.Workflow.CustomActivity
{
    public class CalculateLog : IActivityHandler
    {
        public const string Action = "custom:wf:app::CalculateLog";

        public Task<IDictionary<string, object>> Execute(IDictionary<string, object> inputs, IActivityContext context)
        {
            var logBase = inputs.EnsureDouble("base", null);
            var value = inputs.EnsureDoubleStrict("value");

            double logResult;
            if(logBase != null)
            {
                logResult = Math.Log(value, (double)logBase);
            } else
            {
                logResult = Math.Log(value);
            }

            return Task.FromResult((IDictionary<string, object>)new Dictionary<string, object>()
            {
                ["result"] = logResult
            });
        }
    }
}
```
