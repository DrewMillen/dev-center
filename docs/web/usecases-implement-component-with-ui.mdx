---
title: Custom Component with UI
description: Geocortex Web - Learn how to implement a custom component with UI
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import PrereqsSnippet from "./snippets/prereqs.mdx";
import FrameworkComponentsSnippet from "./snippets/framework-components.mdx";

:::tip
Did you know Geocortex Workflow allows you to [create custom forms](https://docs.geocortex.com/workflow/latest/help/Default.htm#wf5/help/forms.htm#Overview_of_Forms%3FTocPath%3DForms%7COverview%2520of%2520Forms%7C_____0) you can present to an end user?
:::

Implementing a custom component in Geocortex Web gives you one of the highest degrees of flexibility with what you can do. [Components](concepts-components-services.mdx) can display custom, dynamic UI, register operation implementations, store persistent data, and more. They are also one of the most complex ways of customizing your Geocortex Web app, so it's worthwhile to try simplier options like [Commands and Operations](concepts-commands-operations.mdx) or [Workflow](change-default-search-behavior.mdx) first.

By the end of this article, you'll have the knowledge to build a component that displays relevant news items at the top of your map.

## Prerequisites

<PrereqsSnippet />

## Create a Component Skeleton

The first thing we need to do is create the neccesary files for a custom component. A component is simply a [React Component](https://reactjs.org/docs/components-and-props.html) that returns a root `LayoutElement`, so it will be defined in a `.tsx`. file. Every component needs an associated model that extends `ComponentModelBase`.

Create a new folder structure with the following files. These files define a new component with a simple visual structure and export it from the `CustomComponent` folder.

-   `src/components/CustomComponent/CustomComponent.tsx`
-   `src/components/CustomComponent/CustomComponentModel.ts`
-   `src/components/CustomComponent/index.ts`

:::note
In Geocortex Web, components are simply [React Components](https://reactjs.org/docs/components-and-props.html) that return a root `LayoutElement`.
:::

<Tabs
  defaultValue="component"
  values={[
    { label: 'Component', value: 'component', },
    { label: 'Model', value: 'model', },
    { label: 'Component Index', value: 'index', }
  ]
}>
<TabItem value="component">

```tsx title="src/components/CustomComponent/CustomComponent.tsx"
import React from "react";
import { LayoutElement } from "@geocortex/web/components";

export default function CustomComponent(props) {
    return (
        <LayoutElement {...props}>
            <div>I'm so custom</div>
        </LayoutElement>
    );
}
```

</TabItem>
<TabItem value="model">

```ts title="src/components/CustomComponent/CustomComponentModel.ts"
import { ComponentModelBase, serializable } from "@geocortex/web/models";

class CustomComponentModel extends ComponentModelBase {}

export default serializable(CustomComponentModel);
```

</TabItem>
<TabItem value="index">

```ts title="src/components/CustomComponent/index.ts"
import CustomComponentModel from "./CustomComponentModel";

export { default } from "./CustomComponent";
export { CustomComponentModel };
```

</TabItem>
</Tabs>

## Register the Component with the Web SDK

Every component needs to be registered with the Web SDK in order to be used in the [`layout`](concepts-layout.mdx)

Add new calls to `registerComponent` and `registerModel` in `src/index.ts`.

:::note
One key thing to note about this snippet is the `itemType`. The value of the [item type](concepts-advanced-config.mdx#app-items) is what links a component to a model. It's also the string value used for the `$type` property when defining [configuration for a component](implement-component-participate-app-config.mdx).
:::

```ts
import CustomComponent from "./components/CustomComponent"
import { ComponentType } from "react";
...

export default function(registry: LibraryRegistry) {
    ...
    registry.registerComponent({
        name: "my-component",
        namespace: "your.custom.namespace",
        getComponentType: () => CustomComponent as ComponentType,
        // highlight-next-line
        itemType: "custom-component-model",
        title: "Custom Component",
    });
    registry.registerModel({
        getModelType: () => CustomComponentModel,
        // highlight-next-line
        itemType: "custom-component-model",
    });
    ...
}
```

## Add the Component to your Layout

To allow layout to find your component, you need to add the [custom namespace](concepts-layout.mdx#namespaces) of your component defined in the previous step with an `xmlns` tag to the layout.'

```xml title="app/layout.xml"
<?xml version="1.0" encoding="UTF-8"?>
<layout xmlns="https://geocortex.com/layout/v1"
        // highlight-next-line
        xmlns:custom="your.custom.namespace">
    <map id="map-primary" />
</layout>
```

You can then add the component itself to your layout, making sure to use `name` defined when registering the component in `src/index.ts`.

```xml title="app/layout.xml"
<?xml version="1.0" encoding="UTF-8"?>
<layout xmlns="https://geocortex.com/layout/v1"
xmlns:custom="your.custom.namespace">
    <map id="map-primary"/>
    // highlight-next-line
    <custom:my-component/>
</layout>
```

<!-- TODO - ui screenshot -->

If you run the [development server](quick-start.mdx#getting-up-and-running) you should see your custom component up and running.

## Build out your Component's UI

Now that we have a working component, you can build out the UI experience just as you would with any other React Component.

### Example: RSS Feed of News Updates

This React component displays a list of "news items" relevant to your GIS application in a hovering component at the top of the map. In a real application, these news items would be populated by an RSS feed or another news source.

<FrameworkComponentsSnippet />

<Tabs
  defaultValue="component"
  values={[
    { label: 'Component', value: 'component', },
    { label: 'Model', value: 'model', },
    { label: 'Css', value: 'css', },
    { label: 'Layout', value: 'layout', },
    { label: 'Component Index', value: 'newsFeedIndex', },
    { label: 'Registration', value: 'index', },
  ]
}>
<TabItem value="component">

```tsx title="src/components/NewsFeedComponent/NewsFeedComponent.tsx"
import React, { useState } from "react";
import { LayoutElement } from "@geocortex/web/components";
import List from "@geocortex/web/ui/list";
import ListItem from "@geocortex/web/ui/list-item";
import TitleBar from "@geocortex/web/ui/title-bar";
import Button from "@geocortex/web/ui/button";
import DialogActions from "@geocortex/web/ui/dialog-actions";
import "./NewsFeedComponent.css";

export default function NewsFeedComponent(props) {
    const [hidden, setHidden] = useState(false);

    const newsItems: string[] = [
        "New fire hydrant installed at Main and 5th.",
        "Pipe burst at 4th and Broadview",
        "Fire hydrant reported as needs maintenance by citizen.",
    ];

    return (
        <LayoutElement {...props}>
            <List className="news-item-list">
                <DialogActions>
                    <TitleBar text="Recent News"></TitleBar>
                    {hidden && (
                        <Button onClick={() => setHidden(false)}>
                            Show News
                        </Button>
                    )}
                    {!hidden && (
                        <Button onClick={() => setHidden(true)}>
                            Hide News
                        </Button>
                    )}
                </DialogActions>
                {!hidden &&
                    newsItems.map((news, idx) => (
                        <ListItem key={idx}>{news}</ListItem>
                    ))}
            </List>
        </LayoutElement>
    );
}
```

</TabItem>

<TabItem value="model">

```ts title="src/components/NewsFeedComponent/NewsFeedModel.ts"
import { ComponentModelBase, serializable } from "@geocortex/web/models";

class NewsFeedModel extends ComponentModelBase {}

export default serializable(NewsFeedModel);
```

</TabItem>
<TabItem value="css">

```css title="src/components/NewsFeedComponent/NewsFeedComponent.css"
.news-item-list {
    max-height: 200px;
    overflow: scroll;
}
```

</TabItem>
<TabItem value="layout">

```xml title="app/layout.xml"
<?xml version="1.0" encoding="UTF-8"?>
<layout xmlns="https://geocortex.com/layout/v1" xmlns:custom="your.custom.namespace">
    <map id="map-primary">
        // highlight-next-line
        <custom:news-feed slot="top-center"/>
    </map>
</layout>
```

</TabItem>
<TabItem value="newsFeedIndex">

```ts title="src/components/NewsFeedComponent/index.ts"
import NewsFeedModel from "./NewsFeedModel";

export { default } from "./NewsFeedComponent";
export { NewsFeedModel };
```

</TabItem>
<TabItem value="index">

```ts title="src/index.ts"
import NewsFeedComponent, {
    NewsFeedModel,
} from "./components/NewsFeedComponent";
import { ComponentType } from "react";
import { LibraryRegistry } from "@geocortex/web/config";

export default function (registry: LibraryRegistry) {
    registry.registerComponent({
        name: "news-feed",
    namespace: "your.custom.namespace",
        getComponentType: () => NewsFeedComponent as ComponentType,
        itemType: "news-feed-model",
        title: "News Feed",
    });
    registry.registerModel({
        getModelType: () => NewsFeedModel,
        itemType: "news-feed-model",
    });
}
```

</TabItem>
</Tabs>

<!-- TODO - add user interface photo -->

## Running Commands and Operations

When writing custom components or [custom services](implement-service.mdx), you may want to take advantage of Geocortex Web's large [built in suite of command and operations](api-commands-operations.mdx) or your own [custom commands and operations](implement-command-operation.mdx). You can run command and operations through the `UIContext` of the component. 

### Example: Display a Notification to a User

The following example executes the `ui.confirm` operation [through the UIContext](sdk-ui-context.mdx). Calling a command or operation is as simple as retrieving it by name, providing the appropiate generic type for the command or operation, and then calling `execute` with the appropiate arguments. 

:::note
In order to pass arguments to a command or operation, you have to use the correct type for the generic `command` or `operation` function call with the argument and output type for the command or operation. For example, `ui.confirm` takes in a `ConfirmOperationArgs` and returns a `boolean`, as seen in the [API docs](api-commands-operations.mdx#ui-confirm).
:::

```tsx title="src/components/CustomComponent/CustomComponent.tsx"
import React, { useContext } from "react";
import { LayoutElement } from "@geocortex/web/components";
import { UIContext } from "@geocortex/web/ui";
import { ConfirmOperationArgs } from "@geocortex/viewer-framework/messaging/registry/ui";

export default function CustomComponent(props) {
    const context = useContext(UIContext);

    const displayConfirmDialog = async () => {
        const result = await context.operation<ConfirmOperationArgs, boolean>("ui.confirm").execute({
            title:  "Confirm Me",
        })
        
        if(result){
            console.log("I have been confirmed!")
        } else {
            console.warn("I was not confirmed.")
        }
    }
    return (
        <LayoutElement {...props}>
            <button onClick={displayConfirmDialog}>Display Confirm Dialog</button>
        </LayoutElement>
    );
}
```

## Interacting with Application Services

Components can interact with built in Geocortex Web [services](concepts-components-services.mdx#services). Through services, they can interact with the map, application context, workflows, and more. Services can only be injected into a components through their [associated models](implement-component-participate-app-config#component-models). Learn more about how to [inject a service into a component](sdk-service-injection.mdx).

## Interacting with other Components

Components can interact with each other through their [respective models](concepts-layout.mdx#models). A model can either declare that it is exported, like the [map model](TODO-api-link-to-map-model), or that it imports a model. Components like the `<scalebar>` or `<compass>` import the map model, and this is what allows them to respond to changes in the maps state. 

### Example: Component that Adds a Graphics Layer to the Map

The following component has a model which imports the map model as a dependency, and then uses that model to add a graphics layer to the [ArcGIS Map object](https://developers.arcgis.com/javascript/latest/api-reference/esri-Map.html).

<Tabs
  defaultValue="component"
  values={[
    { label: 'Component', value: 'component', },
    { label: 'Model', value: 'model', },
    { label: 'Layout', value: 'layout', }
  ]
}>
<TabItem value="component">

```tsx title="src/components/CustomComponent/CustomComponent.tsx"
import React from "react";
import { LayoutElement, LayoutElementProperties } from "@geocortex/web/components";
import { CustomModel } from ".";

export default function CustomComponent(props: LayoutElementProperties<CustomModel>) {
    return (
        <LayoutElement {...props} style={{ backgroundColor: "white" }}>
            <button onClick={() => props.model.addGraphic()}>Add a Graphic to the Map</button>
        </LayoutElement>
    );
}
```

</TabItem>
<TabItem value="model">

```ts title="src/components/CustomComponent/CustomComponentModel.ts"
import { ComponentModelBase, serializable, importModel } from "@geocortex/web/models";
import { MapExtension } from "@geocortex/api/mapping/MapExtension";
import Graphic from "esri/Graphic";
import GraphicsLayer from "esri/layers/GraphicsLayer";
import { Polygon } from "esri/geometry";
import { SimpleFillSymbol } from "esri/symbols";


@serializable
export default class CustomModel extends ComponentModelBase {
    // highlight-start
    @importModel("map-extension")
    mapExtension: MapExtension;
    // highlight-end

    // based on https://developers.arcgis.com/javascript/latest/sample-code/sandbox/index.html?sample=intro-graphics
    triangleGraphic = new GraphicsLayer({
        graphics: [
            new Graphic({
                symbol: new SimpleFillSymbol({ color: "orange"}),
                geometry: new Polygon({
                    rings: [[
                        [-64.78, 32.3],
                        [-66.07, 18.45],
                        [-80.21, 25.78],
                        [-64.78, 32.3]
                    ]]
                })
            })
        ]
    })

    public addGraphic(){
        // highlight-start
        const esriMap = this.mapExtension.map;
        esriMap.add(this.triangleGraphic);
        // highlight-end
    }
}
```

</TabItem>
<TabItem value="layout">

```xml title="app/layout.xml"
<?xml version="1.0" encoding="utf-8" ?>
<layout xmlns="https://geocortex.com/layout/v1" xmlns:custom="your.custom.namespace">
    <map>
        <custom:custom-component slot="top-center"/>
    </map>
</layout>
```

</TabItem>
</Tabs>


### Example: Component that Exports It's Model 

You can mark a model as exported by adding the `@exportModel` decorator to the model class. The following example shows a model that is exported, and then imported by another model and used.

:::note
Models are imported with the `itemType` name that they are registered with.
:::

<Tabs
  defaultValue="exportedModel"
  values={[
    { label: 'Exported Model', value: 'exportedModel', },
    { label: 'Importing Model', value: 'importingModel', },
    { label: 'Importing Model Component', value: 'importingModelComponent', },
    { label: 'Layout', value: 'layout', }
  ]
}>
<TabItem value="exportedModel">

```ts title="src/components/ExportedModel/ExportedModel.ts"
import { ComponentModelBase, serializable, exportModel } from "@geocortex/web/models";

@exportModel
@serializable
export default class ExportedModel extends ComponentModelBase {
    public someCustomModelProperty: string = "Some Text"
}
```

</TabItem>
<TabItem value="importingModel">

```ts title="src/components/CustomComponent/CustomModel.ts"
import { ComponentModelBase, serializable, importModel } from "@geocortex/web/models";
import { ExportedModel } from "../ExportedModel";

@serializable
export default class CustomModel extends ComponentModelBase {
    @importModel("exported-model")
    exportedModel: ExportedModel;

    public getContentText(){
        return this.exportedModel.someCustomModelProperty;
    }
}
```

</TabItem>
<TabItem value="importingModelComponent">

```tsx title="src/components/importedModel/ExportedModelComponent.tsx"
import React from "react";
import { LayoutElement, LayoutElementProperties } from "@geocortex/web/components";
import { CustomModel } from ".";

export default function CustomComponent(props: LayoutElementProperties<CustomModel>) {
    return (
        <LayoutElement {...props} style={{ backgroundColor: "white" }}>
            <h3>{`Text From the imported Model: "${props.model.getContentText()}"`}</h3>
        </LayoutElement>
    );
}
```

</TabItem>
<TabItem value="layout">

```xml title="app/layout.xml"
<?xml version="1.0" encoding="utf-8" ?>
<layout xmlns="https://geocortex.com/layout/v1" xmlns:custom="your.custom.namespace">
    <stack padding="2">
        <custom:custom-component />
        <custom:exported-model-component />
    </stack>
</layout>
```

</TabItem>
</Tabs>