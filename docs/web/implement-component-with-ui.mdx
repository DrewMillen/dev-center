---
title: Custom Component with UI
description: Geocortex Web - Learn how to implement a custom component with UI
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import PrereqsSnippet from "./snippets/prereqs.mdx";
import FrameworkComponentsSnippet from "./snippets/framework-components.mdx";

:::tip
Did you know Geocortex Workflow allows you to [create custom forms](https://docs.geocortex.com/workflow/latest/help/Default.htm#wf5/help/forms.htm#Overview_of_Forms%3FTocPath%3DForms%7COverview%2520of%2520Forms%7C_____0) you can present to an end user?
:::

Implementing a custom component in Geocortex Web gives you one of the highest degrees of flexibility with what you can do. [Components](concepts-components-services.mdx) can display custom, dynamic UI, register operation implementations, store persistent data, and more. They are also one of the most complex ways of customizing your Geocortex Web app, so it's worthwhile to try simplier options like [Commands and Operations](concepts-commands-operations.mdx) or [Workflow](change-default-search-behavior.mdx) first.

By the end of this article, you'll have the knowledge to build a component that displays relevant news items at the top of your map.

## Prerequisites

<PrereqsSnippet />

## Create a Component Skeleton

The first thing we need to do is create the neccesary files for a custom component. A component is simply a [React Component](https://reactjs.org/docs/components-and-props.html) that returns a root `LayoutElement`, so it will be defined in a `.tsx`. file. Every component needs an associated model that extends `ComponentModelBase`.

Create a new folder structure with the following files. These files define a new component with a simple visual structure and export it from the `CustomComponent` folder.

-   `src/components/CustomComponent/CustomComponent.tsx`
-   `src/components/CustomComponent/CustomComponentModel.ts`
-   `src/components/CustomComponent/index.ts`

:::note
In Geocortex Web, components are simply [React Components](https://reactjs.org/docs/components-and-props.html) that return a root `LayoutElement`.
:::

<Tabs
  defaultValue="component"
  values={[
    { label: 'Component', value: 'component', },
    { label: 'Model', value: 'model', },
    { label: 'Component Index', value: 'index', }
  ]
}>
<TabItem value="component">

```tsx title="src/components/CustomComponent/CustomComponent.tsx"
import React from "react";
import { LayoutElement } from "@geocortex/web/components";

export default function CustomComponent(props) {
    return (
        <LayoutElement {...props}>
            <div>I'm so custom</div>
        </LayoutElement>
    );
}
```

</TabItem>
<TabItem value="model">

```ts title="src/components/CustomComponent/CustomComponentModel.ts"
import { ComponentModelBase, serializable } from "@geocortex/web/models";

class CustomComponentModel extends ComponentModelBase {}

export default serializable(CustomComponentModel);
```

</TabItem>
<TabItem value="index">

```ts title="src/components/CustomComponent/index.ts"
import CustomComponentModel from "./CustomComponentModel";

export { default } from "./CustomComponent";
export { CustomComponentModel };
```

</TabItem>
</Tabs>

## Register the Component with the Web SDK

Every component needs to be registered with the Web SDK in order to be used in the [`layout`](concepts-layout.mdx)

Add new calls to `registerComponent` and `registerModel` in `src/index.ts`.

:::note
One key thing to note about this snippet is the `itemType`. The value of the [item type](TODO-link) is what links a component to a model. It's also the string value used for the `$type` property when defining [configuration for a component](implement-component-participate-app-config.mdx).
:::

```ts
import CustomComponent from "./components/CustomComponent"
import { ComponentType } from "react";
...

export default function(registry: LibraryRegistry) {
    ...
    registry.registerComponent({
        name: "my-component",
        namespace: "your.custom.namespace",
        getComponentType: () => CustomComponent as ComponentType,
        // highlight-next-line
        itemType: "custom-component-model",
        title: "Custom Component",
    });
    registry.registerModel({
        getModelType: () => CustomComponentModel,
        // highlight-next-line
        itemType: "custom-component-model",
    });
    ...
}
```

## Add the Component to your Layout

To allow layout to find your component, you need to add the custom namespace of your component defined in the previous step with an `xmlns` tag to the [layout file](quick-start.mdx#anatomy-of-the-quick-start).

```xml title="app/layout.xml"
<?xml version="1.0" encoding="UTF-8"?>
<layout xmlns="https://geocortex.com/layout/v1"
        // highlight-next-line
        xmlns:custom="your.custom.namespace">
    <map id="map-primary" config="default" />
</layout>
```

You can then add the component itself to your layout, making sure to use `name` defined when registering the component in `src/index.ts`.

```xml title="app/layout.xml"
<?xml version="1.0" encoding="UTF-8"?>
<layout xmlns="https://geocortex.com/layout/v1"
xmlns:custom="your.custom.namespace">
    <map id="map-primary" config="default" />
    // highlight-next-line
    <custom:my-component>
</layout>
```

<!-- TODO - ui screenshot -->

If you run the [development server](quick-start.mdx#getting-up-and-running) you should see your custom component up and running.

## Build out your Component's UI

Now that we have a working component, you can build out the UI experience just as you would with any other React Component.

### Example: RSS Feed of News Updates

This React component displays a list of "news items" relevant to your GIS application in a hovering component at the top of the map. In a real application, these news items would be populated by an RSS feed or another news source.


<FrameworkComponentsSnippet />

<Tabs
  defaultValue="component"
  values={[
    { label: 'Component', value: 'component', },
    { label: 'Model', value: 'model', },
    { label: 'Css', value: 'css', },
    { label: 'Layout', value: 'layout', },
    { label: 'Component Index', value: 'newsFeedIndex', },
    { label: 'Registration', value: 'index', },
  ]
}>
<TabItem value="component">

```tsx title="src/components/NewsFeedComponent/NewsFeedComponent.tsx"
import React, { useState } from "react";
import { LayoutElement } from "@geocortex/web/components";
import List from "@geocortex/web/ui/list";
import ListItem from "@geocortex/web/ui/list-item";
import TitleBar from "@geocortex/web/ui/title-bar";
import Button from "@geocortex/web/ui/button";
import DialogActions from "@geocortex/web/ui/dialog-actions";
import "./NewsFeedComponent.css";

export default function NewsFeedComponent(props) {
    const [hidden, setHidden] = useState(false);

    const newsItems: string[] = [
        "New fire hydrant installed at Main and 5th.",
        "Pipe burst at 4th and Broadview",
        "Fire hydrant reported as needs maintenance by citizen.",
    ];

    return (
        <LayoutElement {...props}>
            <List className="news-item-list">
                <DialogActions>
                    <TitleBar text="Recent News"></TitleBar>
                    {hidden && <Button onClick={() => setHidden(false)}>Show News</Button>}
                    {!hidden && <Button onClick={() => setHidden(true)}>Hide News</Button>}
                </DialogActions>
                {!hidden && newsItems.map((news, idx) => <ListItem key={idx}>{news}</ListItem>)}
            </List>
        </LayoutElement>
    );
}
```

</TabItem>

<TabItem value="model">

```ts title="src/components/NewsFeedComponent/NewsFeedModel.ts"
import { ComponentModelBase, serializable } from "@geocortex/web/models";

class NewsFeedModel extends ComponentModelBase {}

export default serializable(NewsFeedModel);
```

</TabItem>
<TabItem value="css">

```css title="src/components/NewsFeedComponent/NewsFeedComponent.css"
.news-item-list {
    max-height: 200px;
    overflow: scroll;
}
```

</TabItem>
<TabItem value="layout">

```xml title="app/layout.xml"
<?xml version="1.0" encoding="UTF-8"?>
<layout xmlns="https://geocortex.com/layout/v1" xmlns:custom="your.custom.namespace">
    <map id="map-primary" config="default" >
        // highlight-next-line
        <custom:news-feed slot="top-center"/>
    </map>
</layout>
```

</TabItem>
<TabItem value="newsFeedIndex">

```ts title="src/components/NewsFeedComponent/index.ts"
import NewsFeedModel from "./NewsFeedModel";

export { default } from "./NewsFeedComponent";
export { NewsFeedModel };
```

</TabItem>
<TabItem value="index">

```ts title="src/index.ts"
import Test, { TestModel } from "./components/Test";
import NewsFeedComponent, { NewsFeedModel } from "./components/NewsFeedComponent";
import { ComponentType } from "react";

const LAYOUT_NAMESPACE = "custom.foo";

export default function (registry: LibraryRegistry) {
    registry.registerComponent({
        name: "news-feed",
        namespace: "your.custom.namespace",
        getComponentType: () => NewsFeedComponent as ComponentType,
        itemType: "news-feed-model",
        title: "News Feed",
    });
    registry.registerModel({
        getModelType: () => NewsFeedModel,
        itemType: "news-feed-model",
    });
}
```

</TabItem>
</Tabs>

<!-- TODO - add user interface photo -->

## Running Commands and Operations

When writing custom components or [custom services](implement-service.mdx), you may want to take advantage of Geocortex Web's large [built in suite of command and operations](api-commands-operations.mdx) or your own [custom commands and operations](implement-command-operation.mdx). You can run command and operations through a components model
associated model.

### Example: Display a Notification to a User

The following component uses it's model to call the `ui.confirm` command and `ui.display-notification` operation. Calling a command or operation is as simple as retrieving it by name using the [`MessageBus`](api-message-bus.mdx) on the model, and then calling `execute` with the appropiate arguments.

:::note
In order to pass arguments to a command or operation, you have to use the correct type for the generic `messages.command` or `messages.operation` function call with the argument and output type for the command or operation. For example, `ui.confirm` takes in a `ConfirmOperationArgs` and returns a `boolean`, as seen in the [API docs](api-commands-operations.mdx#ui-confirm), so it's `operation()` call would look like this;

```ts
messages.operation<ConfirmOperationArgs, boolean>("ui.confirm");
```

:::

<Tabs
  defaultValue="component"
  values={[
    { label: 'Component', value: 'component', },
    { label: 'Model', value: 'model', },
  ]
}>
<TabItem value="component">

```tsx title="src/components/CustomComponent/CustomComponent.tsx"
import React, { useState } from "react";
import { LayoutElement, LayoutElementProperties } from "@geocortex/web/components";
import { CustomComponentModel } from ".";

export interface CustomComponentProps extends LayoutElementProperties<CustomComponentModel> {}

export default function CustomComponent(props: CustomComponentProps) {
    return (
        <LayoutElement {...props}>
            <button onClick={async () => await props.model.displayConfirm()}>
                Display Confirm Dialog
            </button>
        </LayoutElement>
    );
}
```

</TabItem>
<TabItem value="model">

```ts title="src/components/CustomComponent/CustomComponentModel.ts"
import { serializable, ComponentModelBase } from "@geocortex/web/models";
import {
    DisplayNotificationArgs,
    ConfirmOperationArgs,
} from "@geocortex/viewer-framework/messaging/registry/ui";

@serializable
export default class NewsFeedComponentModel extends ComponentModelBase {
    public async displayConfirm() {
        var result = await this.messages
            .operation<ConfirmOperationArgs, boolean>("ui.confirm")
            .execute({
                message: "Are you sure?",
                title: "Something Important",
                okButtonText: "absolutely.",
                cancelButtonText: "never",
            });

        await this.messages.command<DisplayNotificationArgs>("ui.display-notification").execute({
            message: `You ${result ? "agreed" : "did not agree"} to the dialog`,
        });
    }
}
```

</TabItem>
</Tabs>

## Interacting with Application Services

Components can interact with built in Geocortex Web [services](concepts-components-services.mdx#services). This allows them to interact with the map, application context, workflows, and more. Services can only be injected into a components through their [associated models](implement-component-participate-app-config#component-models). Learn more about how to [inject a service into a component](service-injection.mdx).