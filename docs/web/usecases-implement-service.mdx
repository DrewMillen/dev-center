---
title: Custom Service
description: Geocortex Web - Implement a custom Service
---

import useBaseUrl from "@docusaurus/useBaseUrl";
import PrereqsSnippet from "./snippets/prereqs.mdx";
import FrameworkComponentsSnippet from "./snippets/framework-components.mdx";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

When extending Geocortex Web, you may find yourself creating multiple [components](concepts-components-services.mdx#components) that have a shared concern, like a data source, or a REST endpoint call. Shared concerns like this present a good use case for creating a custom [service](concepts-components-services.mdx#services).
Implementing a custom service in Geocortex Web allows you to implement logic and shared resources that are available on startup to any component. Custom Services are also the reccomended way of registering implementations for [custom commands and operations](usecases-implement-command-operation.mdx).

## Prerequisites

<PrereqsSnippet />

## Example: Service that Implements Commands and Operations

One common use case for implementing a custom service is to register an implementation for a custom command or operation. To learn how to do this, check out the example in [implement commands and operations](usecases-implement-command-operation.mdx).

## Example: Service that Manages Shared Dynamic Data

In this article, we will build a custom service that mocks a periodic fetch of data from a REST endpoint and stores that data for consumption by components. This service will populate a list of news items which will be consumed by the [news feed component](usecases-implement-component-with-ui.mdx#example-rss-feed-of-news-updates) created in a previous article.

### Create a Service Skeleton

Create a new folder structure with the following files. These files define a new service and export it from the `CustomService` folder.

-   `src/services/CustomDataService/CustomDataService.ts`
-   `src/services/CustomDataService/index.ts`

<Tabs
  defaultValue="service"
  values={[
    { label: 'Service', value: 'service', },
    { label: 'Index', value: 'index', }
  ]
}>
<TabItem value="service">

```ts title="src/services/CustomDataService/CustomDataService.ts"
import { ServiceBase } from "@geocortex/web/services";

export default class CustomDataService extends ServiceBase {}
```

</TabItem>
<TabItem value="index">

```ts title="src/services/CustomDataService/index.ts"
export { default } from "./CustomDataService";
```

</TabItem>
</Tabs>

### Register the Custom Service

Every service needs to be registered with the Web SDK in order to be discovered and initialized.

:::note
Services are initialized when they are [injected](sdk-service-injection.mdx) or when a command or operation that they register is called. To initialize a service on startup, you can pass the property `loadOnStartup: true` to the `registerService` call.
:::

Add a call to `registerService` in `src/index.ts`.

```ts
export default function(registry: LibraryRegistry) {
    ...
    registry.registerService({
        id: "custom-service",
        getServiceType: () => CustomService,
    })
    ...
}
```

### Mock a Sporadically Updated Data Source

The purpose of this service will be to create a mock data source for the [news feed component](usecases-implement-component-with-ui.mdx#example-rss-feed-of-news-updates) created in a previous article. We can mock a sporadically updated news feed data source, simulating what a real news feed, with data arriving from an RSS feed at unknown intervals, might behave like. This service exposed a single public property, `newsItems` which will act as a dynamic data source for the news feed component.

:::note
This example uses the `_onInitialize` method override to handle initialization logic, making sure to call the base method.

<!-- TODO - on destroy method once eric updates the pattern -->

:::

```ts title="src/services/CustomDataService/CustomDataService.ts"
import { ServiceBase } from "@geocortex/web/services";
import Collection from "esri/core/Collection";

const newsItems = [
    "New fire hydrant installed at Main and 5th.",
    "Pipe burst at 4th and Broadview",
    "Fire hydrant reported as needs maintenance by citizen.",
    "Crack in road on the Johnson Street Bridge",
    "Fire Hydrant vandalized in front of City Hall",
];

export default class CustomDataService extends ServiceBase {
    private _curIndex = 0;

    // highlight-next-line
    public newsItems: Collection<string> = new Collection<string>();

    private async _fetchRecentNews() {
        // REST request for a news item would go here
        return newsItems[this._curIndex++ % newsItems.length];
    }

    // in a real application, you would want to subscribe to a data source and not use polling.
    private _startPollingForNewItems() {
        const fetchNewsLoop = async () => {
            const newNews = await this._fetchRecentNews();
            let curTime = new Date().toTimeString().split("GMT")[0];
            this.newsItems.unshift(`${curTime}- ${newNews}`);
            setTimeout(fetchNewsLoop, Math.random() * 6000);
        };

        fetchNewsLoop();
    }

    // highlight-start
    protected _onInitialize(): Promise<void> {
        super._onInitialize();
        this._startPollingForNewItems();
        return;
    }
    // highlight-end
}
```

### Consume the Data in the Component Model

Now that we have the news feed data being populated by a service, we need to consume that data in the news feed component.
Following the best practices for implementing components, the news item data should be [managed by the news feed model](usecases-implement-component-participate-app-config.mdx#component-models). Component Models can [inject services](sdk-service-injection.mdx) as properties, and doing so allows us to directly access the dynamically updated `newsItems` property on the service.

:::important
`@inject` must use the `id` that the corresponding service registered in `src/index.ts`.
:::

```ts title="src/services/NewsFeedModel.ts"
import { ComponentModelBase, serializable } from "@geocortex/web/models";
import Collection from "esri/core/Collection";
import CustomDataService from "../../services/CustomDataService";
import { inject } from "@geocortex/web/services";

@serializable
export default class NewsFeedModel extends ComponentModelBase {
    // highlight-start
    @inject("custom-data-service")
    customDataService: CustomDataService | undefined;
    // highlight-end

    /**
     * Array of items to display in the news feed
     */
    newsItems: Collection<string>;

    protected _onInitialize(): Promise<void> {
        super._onInitialize();
        // highlight-next-line
        this.newsItems = this.customDataService.newsItems;
    }
}
```

### Complete Example

Finally, we can bring it all together, and add the news item component and styling to the application. The news feed component watches for changes on the news feed model's `newsItems` property, which is in turn linked to the custom service's `newsItems` property. In this way, we've built a service which exposes shared data to components. Multiple news feed component could be created, and they would all rely on a single copy of the news items. For more information on how the news feed component was built, see the article on [custom components](usecases-implement-component-with-ui.mdx) and [linking app config to custom components](usecases-implement-component-participate-app-config.mdx#example-model-for-the-news-feed-component).

<FrameworkComponentsSnippet />

<Tabs
  defaultValue="component"
  values={[
    { label: 'News Feed Component', value: 'component', },
    { label: 'Css', value: 'css', },
    { label: 'News Feed Model', value: 'model', },
    { label: 'Data Service', value: 'service', },
    { label: 'Registration', value: 'index', },
    { label: 'UI', value: 'ui', },
  ]
}>
<TabItem value="service">

```ts title="src/services/CustomDataService/CustomDataService.ts"
import { ServiceBase } from "@geocortex/web/services";
import Collection from "esri/core/Collection";

const newsItems = [
    "New fire hydrant installed at Main and 5th.",
    "Pipe burst at 4th and Broadview",
    "Fire hydrant reported as needs maintenance by citizen.",
    "Crack in road on the Johnson Street Bridge",
    "Fire Hydrant vandalized in front of City Hall",
];

export default class CustomDataService extends ServiceBase {
    private _curIndex = 0;

    public newsItems: Collection<string> = new Collection<string>();

    private async _fetchRecentNews() {
        // REST request for a news item would go here
        return newsItems[this._curIndex++ % newsItems.length];
    }

    private _startPollingForNewItems() {
        const fetchNewsLoop = async () => {
            const newNews = await this._fetchRecentNews();
            const curTime = new Date().toTimeString().split("GMT")[0];
            this.newsItems.unshift(`${curTime}- ${newNews}`);
            setTimeout(fetchNewsLoop, Math.random() * 6000);
        };

        fetchNewsLoop();
    }

    protected _onInitialize(): Promise<void> {
        super._onInitialize();
        this._startPollingForNewItems();
        return;
    }
}
```

</TabItem>
<TabItem value="component">

```tsx title="src/component/NewsFeed/NewsFeed.tsx"
import React from "react";
import {
    LayoutElement,
    LayoutElementProperties,
} from "@geocortex/web/components";
import "./NewsFeed.css";
import { NewsFeedModel } from ".";
import { useWatchCollectionAndRerender } from "@geocortex/web/ui/hooks";
import List from "@geocortex/web/ui/list";
import ListItem from "@geocortex/web/ui/list-item";
import TitleBar from "@geocortex/web/ui/title-bar";
import "./NewsFeed.css";
import Typography from "@geocortex/web/ui/typography"

export default function NewsFeed(props: LayoutElementProperties<NewsFeedModel>) {
    const { model } = props;

    useWatchCollectionAndRerender(model.newsItems);

    return (
        <LayoutElement {...props}>
            <List className="news-item-list">
                <TitleBar text="Recent News" />
                {model.newsItems.toArray().map((news, idx) => (
                    <ListItem key={idx}>
                        <Typography>{news}</Typography>
                    </ListItem>
                ))}
            </List>
        </LayoutElement>
    );
}
```

</TabItem>
<TabItem value="model">

```ts title="src/component/NewsFeed/NewsFeedModel.ts"
import { ComponentModelBase, serializable } from "@geocortex/web/models";
import Collection from "esri/core/Collection";
import CustomDataService from "../../services/CustomDataService";
import { inject } from "@geocortex/web/services";

@serializable
export default class NewsFeedModel extends ComponentModelBase {
    @inject("custom-data-service")
    customDataService: CustomDataService;

    /**
     * Array of items to display in the news feed
     */
    newsItems: Collection<string>;

    constructor() {
        super();
    }

    protected _onInitialize(): Promise<void> {
        super._onInitialize();
        this.newsItems = this.customDataService.newsItems;
        return;
    }
}
```

</TabItem>
<TabItem value="css">

```css title="src/components/NewsFeed/NewsFeed.css"
.news-item-list {
    max-height: 15em;
    overflow: scroll;
    padding: 1em;
}
```

</TabItem>
<TabItem value="index">

```ts title="src/index.ts"
import CustomDataService from "./services/CustomDataService";
import NewsFeed, {
    NewsFeedModel,
} from "./components/NewsFeed";
import { LibraryRegistry } from "@geocortex/web/config";
import { ComponentType } from "react";

export default function (registry: LibraryRegistry) {
    registry.registerService({
        // highlight-next-line
        id: "custom-data-service",
        getServiceType: () => CustomDataService,
    });
    registry.registerComponent({
        name: "news-feed",
        namespace: "your.custom.namespace",
        getComponentType: () => NewsFeed as ComponentType,
        itemType: "news-feed-model",
        title: "News Feed",
    });
    registry.registerModel({
        getModelType: () => NewsFeedModel,
        itemType: "news-feed-model",
    });
}
```

</TabItem>
<TabItem value="ui">
<img src={useBaseUrl("img/web-implement-service-example.png")}/>
</TabItem>
</Tabs>

## Example: Service with Initialization and Cleanup

Sometimes, a service is required to perform intialization and cleanup actions, for example, to intialize dynamic data and cleanup dangling references. The `ServiceBase` class has two methods to achieve this:

-   `_onInitialize()`, which can be overridden,
-   and `destroy()`, which can be implemented to facilitate cleanup.

The following service uses these methods to subscribe to an event and cleanup the event handler afterwards.

:::important
Always call `super._onInitialize()` before any custom initialization logic.
:::

```ts
import { ServiceBase } from "@geocortex/web/services";
import { MapEvent } from "@geocortex/viewer-framework/messaging/registry/map";

export default class CustomService extends ServiceBase {
    handles: IHandle[] = [];

    protected async _onInitialize(): Promise<void> {
        await super._onInitialize();
        this.handles.push(
            this.messages.events.map.initialized.subscribe((e: MapEvent) => {
                console.log(
                    "Map Initialized, do your map dependent model setup here."
                );
            })
        );
        return;
    }

    destroy(): void {
        this.handles.forEach((h) => h.remove());
    }
}
```

## Example: Configurable Service

Like components, services can be configured through the [app config](concepts-app-config.mdx). A service can participate in the config by extending the `ConfigurableServiceBase` class. The following example demonstrates a service with one configurable property `name`, which is used to produce a string that is rendered by a component.

:::tip
Check out the [article on creating a configurable component](usecases-implement-component-participate-app-config.mdx) for more details on how configuration related code like `_getSerializableProperties()` works.
:::


<Tabs
  defaultValue="service"
  values={[
    { label: 'Service', value: 'service', },
    { label: 'Model', value: 'model', },
    { label: 'Component', value: 'component', },
    { label: 'Registration', value: 'registration', },
    { label: 'App Config', value: 'config', },
    { label: 'Layout', value: 'layout', },
  ]
}>
<TabItem value="service">

```ts title="src/services/CustomServiceWithConfig"
import { ConfigurableServiceBase, PropertyDefs, serializable } from "@geocortex/web/services";
import { ServiceModelProperties } from "@geocortex/web/models";

export interface CustomServiceProperties extends ServiceModelProperties {
    name: string;
}

@serializable
export default class CustomServiceWithConfig extends ConfigurableServiceBase<CustomServiceProperties> {
    name: string;

    public async sayHello(): Promise<string> {
        return `Hello, ${this.name}`;
    }

    protected _getSerializableProperties(): PropertyDefs<CustomServiceProperties> {
        return {
            ...super._getSerializableProperties(),
            name: {
                serializeModes: ["initial"],
                serialize: () => this.name,
                default: "Noah",
            }
        }
    }
}

```

</TabItem>
<TabItem value="model">

```ts title="src/components/CustomModel.ts"
import { ComponentModelBase, serializable } from "@geocortex/web/models";
import { inject } from "@geocortex/web/services";
import CustomServiceWithConfig from "../../services/CustomServiceWithConfig";

@serializable
export default class CustomModel extends ComponentModelBase {
    @inject("custom-service-with-config")
    public configurableService: CustomServiceWithConfig;
}
```

</TabItem>
<TabItem value="component">

```tsx title="src/components/CustomComponent.tsx"
import React, { useEffect, useState } from "react";
import { LayoutElement, LayoutElementProperties } from "@geocortex/web/components";
import CustomModel from "./CustomModel";

export default function ComponentWithIcon(props: LayoutElementProperties<CustomModel>) {
    const { model } = props;
    const [content, setContent] = useState("");

    useEffect(() => {
        (async() => {
            const helloText = await model.configurableService.sayHello();
            setContent(helloText);
        })();
    })

    return (
        <LayoutElement {...props} style={{ backgroundColor: "white" ]}}>
            <h2>{content}</h2>
        </LayoutElement>
    );
}
```

</TabItem>
<TabItem value="registration">

```ts title="src/index.ts"
import { LibraryRegistry, ServiceConstructor } from "@geocortex/web/config";
import { ComponentType } from "react";
import CustomComponent from "./components/CustomComponent/CustomComponent";
import CustomModel from "./components/CustomComponent/CustomModel";
import CustomServiceWithConfig from "./services/CustomServiceWithConfig";

export default function (registry: LibraryRegistry) {
    registry.registerComponent({
        name: "my-component",
        namespace: "your.custom.namespace",
        getComponentType: () => CustomComponent as ComponentType,
        itemType: "custom-model",
        title: "Custom Component",
    });
    registry.registerModel({
        getModelType: () => CustomModel,
        itemType: "custom-model",
    });
    registry.registerService({
        id: "custom-service-with-config",
        title: "Custom Service with Config",
        getServiceType: () => CustomServiceWithConfig as ServiceConstructor,
        itemType: "custom-service"
    })
}
```

</TabItem>
<TabItem value="config">

```json title="app/app.json"
{
    "items": [
        {
            "id": "custom-service-id",
            "$type": "custom-service",
            "name": "Ian"
        }
    ]
}

```

</TabItem>
<TabItem value="layout">

```xml title="app/layout.xml"
<?xml version="1.0" encoding="UTF-8"?>
<layout xmlns="https://geocortex.com/layout/v1"
        xmlns:custom="your.custom.namespace">
    <map id="map-primary" >
        <custom:my-component slot="top-center" padding="1"/>
    </map>
</layout>
```

</TabItem>
</Tabs>